[[AdE]]
### Caratteristiche
- 32-bit processor, RISC, 32-bit opcodes
- 13 Registri _general purpose_ a 32 bit, $R0 \rightarrow R12$
- 1 _Registro Stack Pointer_, $R13/SP$
- 1 _Link Register_ per le chiamate a subroutine, $R14/LR$
- 1 _Program Counter_, $R15/PC$
- 1 _Processor Status Register_, $PSR$, che memorizza i flag condizionali ed il modo di esecuzione
- Differenti _execution modes_
# Inside the CPU
![[Pasted image 20231106111824.png]]
- **ALU** (Arithmetic Logic Unit);
- **CU** (Control Unit);
- **Instruction Register**: contiente l'istruzione che la CPU esegue in quell'istante;
- **Program Counter**: registro gestito quasi interamente dalla CPU;
- **Bus Interface**: collegamenti, "strade" su cui viaggia l'informazione.
### Memoria
Da immaginare come un enorme cassettiera formata da **cassetti numerati**, in modo contiguo da 0 a $2^n$. 
Il numero del cassetto si chiama **indirizzo di memoria**, che contiene le operazioni che la CPU deve eseguire.
## Fasi della CPU
1. **Fetch Phase**: trasferimento su IR della word contenuta nella locazione puntata dal PC: $IR\leftarrow[[PC]]$
2. **incremento** del PC in modo da puntare alla word successiva: $PC\leftarrow [PC]+4$
3. **Execution Phase**: decodifica ed esecuzione dell'istruzione presente su IR
### Set di istruzioni
#### MOV
- Caricamento di un valore immediato nel registro
`MOV Rn, #immediate16`
- Copia di un valore da un registro all'altro
`MOV Rn, Rm
#### Arithmetic-Logic Instruction (GENERIC)
- **Rd** = Registro destinazione
- **Rn** = Registro numero
- **Rm** = Registro numero
- **op** = operazione *aritmetica* o *logica*

`op Rd, Rn, #imm12
`op Rd, Rn, Rm
`op Rd, #imm12
`op Rd, Rn
##### Arithmetic Instructions
- ADD
- SUB
##### Logic Instructions
- AND
- ORR
- EOR
#### CMP - Compare
- Confronta due registri, o un registro con un valore immediato effettuando una sottrazione
`CMP Rn, #immediate16`
`CMP Rn, Rm
- Aggiorna i flag del processore (*PSR*) sulla base del risultato
#### PSR - Program Status Register
E' un registro (bit-mapped) i cui bit rappresentano:
- i *flags* relativi al risultato dell'ultima operazione di CMP
- i flag di *interrupt*
**N** - Negative result
**Z** - Zero result
**C** - Carry set
**V** - Overflow
#### B{cond} target - Salto condizionato
- Effettua un salto alla destinazione (relativa al PC - R15) specificata se la condizione è vera
`B:
	`EQ
	`NE
	`HS >= unsigned
	`LO < unsigned
	`HI > unsigned
	`LS <= unsigned
	`LT < signed
	`LE <= signed

L'istruzione `BL target` effettua un salto alla destinazione specificata *copiando* sul **LR** - R14 il valore del **PC** - R15
#### LOAD - Accesso alla memoria
- L'istruzione preleva una word di memoria dall'indirizzo di memoria indicato e la trasferisce ad un registro di destinazione
- L'indirizzo può essere indicato da un registro (puntatore) più un eventuale offset immediato o registro
`LDR Rd, [Rs]
`LDR Rd, [Rs, #offset]
`LDR Rd, [Rs, #offset]!` ==> *pre*-incremento
`LDR Rd, [Rs], #offset` ==> *post*-incremento
`LDR Rd, [Rs, +/- Ro]
`LDR Rd, [Rs, +/- Ro]!
`LDR Rd, [Rs], +/- Ro
#### STORE - Accesso alla memoria
- L'istruzione preleva una word di memoria dall'indirizzo di memoria indicato e la trasferisce ad un registro di destinazione
- L'indirizzo può essere indicato da un registro (puntatore) più un eventuale offset immediato o registro
`STR Rd, [Rs]
`STR Rd, [Rs, #offset]
`STR Rd, [Rs, #offset]!` ==> *pre*-incremento
`STR Rd, [Rs], #offset` ==> *post*-incremento
`STR Rd, [Rs, +/- Ro]
`STR Rd, [Rs, +/- Ro]!
`STR Rd, [Rs], +/- Ro
